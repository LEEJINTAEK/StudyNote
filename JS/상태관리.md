# 상태관리 개념 정리 📝

<br />

## 목차

- [**상태관리?**](#상태관리)
- [**Context API**](#context-api)
- [**Redux 세팅**](#redux-세팅하기)

<br />
<br />

## 상태관리?

<br />

- 앱 상에서의 데이터를 메모리 등에 저장하고 하나 이상의 <br /> 컴포넌트에서 데이터를 공유하는 것
- 한 컴포넌트 안에서의 상태, 여러 컴포넌트 간의 상태, <br /> 전체 앱의 상태 관리를 모두 포함

<br />

### 장점?

1. 높은 품질의 코드를 작성하는 데 유리
2. 성능 최적화, 네트워크 최적화 유리
3. 데이터 관리의 고도화 (localStorage 활용한 persist state)

<br />

### 단점..

1. Boilerplate 문제
2. 파악해야 로직과 레이어가 많아짐
3. 잘못 사용할 경우, 앱의 복잡도만을 높이거나 성능을 악화

<br />
<br />

## Context API??

<p> Context API와 Redux는 둘 다 상태 관리를 위한 도구로 React 애플리케이션에서 상태를 효율적으로 관리하기 위해 사용</p>

<br />

사용해보기

```js
export let 재고context = React.createContext();

function App() {
  let [재고, 재고변경] = useState([10, 11, 12]);

  return (
    <Context1.Provider value={{ 재고, shoes }}>
      <Detail shoes={shoes} />
    </Context1.Provider>
  );
}
```

1. 일단 createContext() 함수를 가져와서 context를 하나 만들어준다. <br />
   (context를 쉽게 비유해서 설명하자면 state 보관함)

2. 아까만든 Context1로 원하는 곳을 감싸고 공유를 원하는 state를 value 안에 다 적으면 된다. <br />
   그럼 이제 Context1로 감싼 모든 컴포넌트와 그 자식컴포넌트는 state를 props 전송없이 직접 사용가능 !!

```js
import { useState, useEffect, useContext } from "react";
import { Context1 } from "./../App.js";

function Detail() {
  let { 재고 } = useContext(Context1);

  return <div>{재고}</div>;
}
```

Context에 있던 state를 꺼내 쓰려면

3. Context1을 import 하고 <br />
4. useContext() 안에 담으면 된다. (Context 해체해주는 함수)
5. 그럼 그 자리에 공유했던 모든 state가 남고, 변수에 담아서 가져다쓰거나 하면 된다.

<br />
<br />

**Context API 단점**

1. state 변경시 쓸데없는 컴포넌트까지 전부 재렌더링이 되고

2. useContext() 를 쓰고 있는 컴포넌트는 나중에 다른 파일에서 재사용할 때 Context를 import 하는게 귀찮아질 수 있다.

3. Context API는 공식문서에도 나와있듯이 props drilling을 위한 것이지 <br />
   전역 상태관리를 지원하는 기능이 아니다.

그래서 이것 보다는 redux 같은 외부라이브러리를 많이들 사용한다니... 지금부터 Redux를 공부해본다.

<br />
<br />
<br />

## Redux

- Redux는 Reducer, action, store로 구성된다.
- 완벽하게 flux 패턴을 따라 구현되지는 않았지만 기본<br /> 사상은 같은 선상에 있다고 볼 수 있다.
- Redux는 Dispatcher를 명시적으로 생성하지 않고도 Flux를 구현할 수 있도록 작성되었다. <br />
  -> Dispatcher를 생략할 수 있다. <br />
  -> 실제 디스패치 동작은 스토어의 dispatch 메소드를 호출하여 실행한다.

<br />

![image](https://github.com/LEEJINTAEK/StudyNote/assets/109197023/c200916a-9c1d-4693-aa52-79958ad7f605)

<br />

1. 설치

```shell
npm install @reduxjs/toolkit react-redux
```

<br />

2. 세팅

```js
import { configureStore } from "@reduxjs/toolkit";

export default configureStore({
  reducer: {},
});
```

<br />

<p>아무데나 store.js 파일을 만들어서 위 코드를 복붙(state들을 보관하는 파일) </p>

<br />

```js
import { Provider } from "react-redux";
import store from "./store.js";

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(
  <React.StrictMode>
    <Provider store={store}>
      <BrowserRouter>
        <App />
      </BrowserRouter>
    </Provider>
  </React.StrictMode>
);
```

<br />

index.js 파일가서 Provider 라는 컴포넌트와 아까 작성한 파일을 import <br />

그리고 밑에 <Provider store={import해온거}> 이걸로 <App/> 을 감싸면 됨. <br />

그럼 이제 <App>과 그 모든 자식컴포넌트들은 store.js에 있던 state를 맘대로 꺼내쓸 수 있음 <br />

<br />
<br />

## 상태 관리 기술이 해결하는 문제들

<br />

### 데이터 캐싱과 재활용

- SPA에서 페이지 로딩 시마다 모든 데이터를 로딩한다면, <br /> 사용자 경험 측면에서 MPA를 크게 넘어서기 힘듦
- 오히려 네트워크 요청 수가 많아져 더 느릴 수 있음
- 변경이 잦은 데이터가 아니라면, 데이터를 캐싱하고 재활용함
- 변경이 잦다면, 데이터의 변경 시점을 파악해 최적화
  <br /> (일정 시간마다 서버에 저장, 타이핑 5초후..서버에 저장)

<br />

### Prop Drilling

- 컴포넌트가 복잡해지는 경우, 상위 부모와 자식 컴포넌트 간의 깊이가 커진다.
- 최하당의 자식 컴포넌트가 데이터를 쓰기 위해 <br />
  최상위 컴포넌트로부터 데이터를 보내야 하는 상황이 발생
- Context API 등을 활용, 필요한 컴포넌트에서 데이터를 가져올 수 있다.
- 컴포넌트 간의 결합성을 낮춘다.
