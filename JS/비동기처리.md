# 비동기 처리

<br />
<br />

## 비동기 처리??

<br />

**자바스크립트의 비동기 처리란 특정 코드의 연산이 끝날 때까지 코드의 실행을 멈추지 않고 다음 코드를 먼저 실행하는 자바스크립트의 특성을 의미**

<br />

`예1 (제이쿼리 ajax)`

```js
unction getData() {
	var tableData;
	$.get('https://domain.com/products/1', function(response) {
		tableData = response;
	});
	return tableData;
}

console.log(getData()); // undefined

//1. 서버에서 받아온 데이터는 response 인자에 담김-> 그리고 tableData = response; 코드로 받아온 데이터를 tableData라는 변수에 저장
//2. getData()를 호출하면 어떻게 될까? 결과는 undefined
//3. 그 이유는 $.get()로 데이터를 요청하고 받아올 때까지 기다려주지 않고 다음 코드인 return tableData;를 실행했기 때문이다. 따라서, getData()의 결과 값은 초기 값을 설정하지 않은 tableData의 값 undefined를 출력한다.
```

<br />

`에 (setTimeout)`

```js
// #1
console.log("Hello");
// #2
setTimeout(function () {
  console.log("Bye");
}, 3000);
// #3
console.log("Hello Again");
```

**이렇게 특정 로직의 실행이 끝날 때까지 기다려주지 않고 나머지 코드를 먼저 실행하는 것이 비동기 처리**

<br />
<br />

## 콜백 함수 & 콜백 지옥

<br />

위의 비동기 처리의 문제점을 어떻게 해결할 수 있을까?
답은 **콜백 함수** 이용한다.

```js
function getData(callbackFunc) {
  $.get("https://domain.com/products/1", function (response) {
    callbackFunc(response); // 서버에서 받은 데이터 response를 callbackFunc() 함수에 넘겨줌
  });
}

getData(function (tableData) {
  console.log(tableData); // $.get()의 response 값이 tableData에 전달됨
});
```

**데이터가 준비된 시점에서만 원하는 동작(특정 값을 출력한다 등)을 수행할 수 있다.**

그러나!! 콜백 함수는 또 다른 문제를 낳는다..

`콜백 지옥의 예`

```js
$.get("url", function (response) {
  parseValue(response, function (id) {
    auth(id, function (result) {
      display(result, function (text) {
        console.log(text);
      });
    });
  });
});
```

<br />

1. 웹 서비스를 개발하다 보면 서버에서 데이터를 받아와 화면에 표시하기까지 인코딩, 사용자 인증 등을 처리해야 하는 경우가 있다.
2. 만약 이 모든 과정을 비동기로 처리해야 한다고 하면 위와 같이 콜백 안에 콜백을 계속 무는 형식으로 코딩을 하게 된다.
3. 이러한 코드 구조는 가독성도 떨어지고 로직을 변경하기도 어려운데, 이와 같은 코드 구조를 **콜백 지옥**이라고 한다.

<br />

콜백 지옥을 해결하기 위해서는

```js
function parseValueDone(id) {
  auth(id, authDone);
}
function authDone(result) {
  display(result, displayDone);
}
function displayDone(text) {
  console.log(text);
}
$.get("url", function (response) {
  parseValue(response, parseValueDone);
});
```

위와 같이 분리하는 방법도 있고, 다른 두가지 방법이 있다.

1. promise
2. async

<br />
<br />

## async & away ?

<br />

```js
function logName() {
  const user = fetchUser("domain.com/users/1"); //서버에서 데이터를 받아오는 HTTP 통신 코드
  if (user.id === 1) {
    console.log(user.name);
  }
}

// async & await 적용
async function logName() {
  const user = await fetchUser("domain.com/users/1"); //서버에서 데이터를 받아오는 HTTP 통신 코드
  if (user.id === 1) {
    console.log(user.name);
  }
}
```

<br />

- 일반적으로 자바스크립트의 비동기 처리 코드는 위 같이 콜백을 사용해야지 코드의 실행 순서를 보장받을 수 있다.
- 먼저 함수의 앞에 async 라는 예약어를 붙인다.
- 함수의 내부 로직 중 HTTP 통신을 하는 비동기 처리 코드 앞에 await를 붙인다.
- 비동기 처리 메서드가 꼭 프로미스 객체를 반환해야 await가 의도한 대로 동작한다.
  **await의 대상이 되는 비동기 처리 코드는 Axios 등 프로미스를 반환하는 API 호출 함수**

<br />

### 실용 예제

<br />

```js
//각각 사용자 정보와 할 일 정보가 담긴 프로미스 객체
function fetchUser() {
  const url = "https://jsonplaceholder.typicode.com/users/1";
  return fetch(url).then(function (response) {
    return response.json();
  });
}

function fetchTodo() {
  const url = "https://jsonplaceholder.typicode.com/todos/1";
  return fetch(url).then(function (response) {
    return response.json();
  });
}
//위 함수들을 실행하면 각각 사용자 정보와 할 일 정보가 담긴 프로미스 객체가 반환
```

1. fetchUser()를 이용하여 사용자 정보 호출
2. 받아온 사용자 아이디가 1이면 할 일 정보 호출
3. 받아온 할 일 정보의 제목을 콘솔에 출력

<br />

```js
async function logTodoTitle() {
  const user = await fetchUser();
  if (user.id === 1) {
    const todo = await fetchTodo();
    console.log(todo.title); // delectus aut autem
  }
}
//fetch() API는 크롬과 같은 최신 브라우저에서만 동작
```

<br />

- logTodoTitle()를 실행하면 콘솔에 delectus aut autem가 출력될 것
- 위 비동기 처리 코드를 만약 콜백이나 프로미스로 했다면 훨씬 더 코드가 길어졌을 것이고 인덴팅 뿐만 아니라 가독성도 좋지 않았을 것.
- 이렇게 async await 문법을 이용하면 기존의 비동기 처리 코드 방식으로 사고하지 않아도 되는 장점을 가짐

<br />

### 예외 처리

<br />

`발생한 네트워크 통신 오류뿐만 아니라 간단한 타입 오류 등의 일반적인 오류 잡기 위해!!`

async & await에서 예외를 처리하는 방법은 바로 try catch!!

<br />

```js
async function logTodoTitle() {
  try {
    const user = await fetchUser();
    if (user.id === 1) {
      const todo = await fetchTodo();
      console.log(todo.title); // delectus aut autem
    }
  } catch (error) {
    console.log(error);
  }
}
```

**발견된 에러는 error 객체에 담기기 때문에 에러의 유형에 맞게 에러 코드를 처리해주면 됨**

<br />
<br />

## 출처

> https://joshua1988.github.io/web-development/javascript/js-async-await/#async--await-%EC%98%88%EC%99%B8-%EC%B2%98%EB%A6%AC
