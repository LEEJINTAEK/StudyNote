# 브라우저 렌더링 ✏️

<br />
<br />

## 사전 지식

1. 브라우저?

- 사용자가 선택한 자원을 서버에 요청하고 브라우저에 표시하는 것
- 자원은 HTML문서, PDF, 이미지 등 다양한 형태를 띌 수 있다.
- 자원의 주소는 URL(Uniform Resource Identifier)에 의해 정해진다.
- ex) 최근 종료된 인터넷 익스플로러부터 파이어폭스, 사파리, 크롬, 오페라 등

2. 렌더링?

- HTML, CSS, JavaScript 파일을 파싱해, 브라우저에 시각적으로 출력하는 과정이다.

3. 파싱(parsing)

- 프로그래밍 언어로 작성된 파일을 실행시키기 위해 구문 분석(syntax analysis)을 하는 단계이다.
- 파일의 문자열들을 문법적 의미를 갖는 최소 단위인 토큰으로 분해하고, 이 토큰들을 문법적 의미와 구조에 따라 노드라는 요소로 만든다.
- 노드들은 상하관계를 반영해 트리를 형성하는데, 이 트리를 파스트리라고 한다.

<br />
<br />

들어가기 전 간략하게 과정을 보자
<br />

<img width="393" alt="랜더링" src="https://user-images.githubusercontent.com/109197023/222730909-389fc4db-30e8-4d9b-9d95-8ec83f4743ae.PNG">

<br />

**과정**

1. HTML 파싱(HTML Parsing): 브라우저는 HTML 문서를 받아들이고, HTML 태그들을 파싱하여 DOM 트리(DOM tree)를 생성한다.
   DOM 트리는 HTML 문서의 계층 구조를 나타내는 트리 구조이다.

2. CSS 파싱(CSS Parsing): 브라우저는 CSS 문서를 받아들이고, CSS 규칙들을 파싱하여 스타일 규칙 트리(CSS Rule Tree)를 생성한다.
   스타일 규칙 트리는 HTML 요소들에 적용되는 스타일 규칙들을 나타내는 트리 구조이다.

3. 레이아웃(Layout): 브라우저는 DOM 트리와 스타일 규칙 트리를 이용하여 렌더링 트리(Render Tree)를 생성한다.
   렌더링 트리는 화면에 표시되는 노드들만으로 구성된 트리 구조이다.

4. 페인팅(Painting): 브라우저는 렌더링 트리를 이용하여 화면에 픽셀을 그리는 과정을 수행한다.
   이 과정을 페인팅(Painting)이라고 한다.

5. 컴포지팅(Compositing): 브라우저는 페인팅된 이미지들을 적절하게 합성하여 최종 이미지를 생성한다.
   이 과정을 컴포지팅(Compositing)이라고 한다.

<br />
<br />

## 웹 브라우저의 렌더링 과정??

<br />

**1. 브라우저는 HTML, CSS, JS, 이미지, 폰트 등 리소스를 서버에 요청하고, 응답으로 받아온다.**

<img width="380" alt="요청" src="https://user-images.githubusercontent.com/109197023/222733087-93f065d6-3563-4083-80e6-a8e45f80c639.PNG">

<br />

- 여기에는 index.html 뿐만 아니라 요청한 적도 없는 이미지같은 다른 리소스까지 딸려오고 있다.
- 브라우저 렌더링 엔진은 HTML 파일을 파싱할 때, 위에서 아래로 한 줄 한 줄 파싱한다. 그러다가 외부 리소스를 가져오는 태그를 만나면 리소스 파일을 서버로 요청한다.
- 보통 CSS파일은 link, Javascript파일은 script, 이미지는 img로 가져오는데, 이런 태그들을 만나 리소스들을 서버에서 받아오는 것이다.

 <br />
 <br />

**2. 브라우저 렌더링 엔진은 받아온 HTML, CSS를 파싱해 DOM, CSSOM을 생성하고, 이들을 결합해 렌더 트리를 생성한다.**

<br />

2-1. HTML 파싱, DOM 생성

dom이 무엇인가?는 JS-Study

<br />
<br />

2-2. CSS 파싱, CSSOM 생성

<br />

- 앞서 html 파일을 파싱하다가 link, style 태그를 만나면 파싱을 잠시 멈추고 리소스 파일을 서버로 요청한다고 언급했었다.
- 이 태그들은 CSS 파일을 가져올 때 보통 쓰는데, 이렇게 가져온 CSS 파일도 HTML과 마찬가지로 파싱을 한다.
- 서버에서 받아온 2진수 파일을 문자열로 인코딩하고, 토큰 단위로 나누고, 노드를 생성하고, 트리를 만들고.. 이렇게 파싱해 만든 트리는 CSSOM(CSS Object Model) 이라고 한다.
- CSSOM을 생성하고 나면, HTML파일은 다시 본론으로 돌아가 파싱을 멈췄던 부분부터 다시 파싱을 시작해 DOM을 마저 생성한다.
- CSS의 속성은 상속이 되기 때문에, 이를 반영한다는 점이다. 예를들어 ul 이 부모 요소이고, li를 자식요소로 가진다고 생각해보자. 아래 코드처럼 ul는 파란색 속성을 가지고 있는데, 이 속성은 자식 요소인 li도 상속받게 된다. 따라서 li는 상속받은 color:blue와 자신이 가지고 있던 font-size 속성 두 가지를 갖게 된다.

<img width="370" alt="cssom" src="https://user-images.githubusercontent.com/109197023/222738343-9e40a6d6-cb13-4894-881c-b6739fa3d7b6.PNG">

<br />
<br />

2-3. 렌더 트리 생성

<br />

- DOM과 CSSOM은 굉장히 비슷하게 생겼지만, 서로 다른 속성들을 가진 독립적인 트리들이다. 알다시피 HTML은 구조를, CSS는 디자인을 담당하기 때문에 둘을 합치는 작업이 필요하다.
- 렌더 트리는 이름처럼 렌더링을 목적으로 만드는 트리이다.
- 렌더링은 브라우저가 이제 진짜로 사용자에게 보여주기 위한 화면을 그리는 과정이기 때문에, 보이지 않을 요소들은 이 트리에 포함하지 않는다.
- 예를들어, DOM에서는 meta태그같은 정보전달 목적의 태그나, CSSOM에서는 display:none으로 보이지 않게 해둔 요소 (정확히는 노드)들은 렌더 트리에서는 제외된다. (단, visibility: hidden은 레이아웃 트리에 포함되니 주의하기!)

<img width="400" alt="렌더트리" src="https://user-images.githubusercontent.com/109197023/222739393-f94722e6-8b46-4ced-bd2f-62f31b3916f3.PNG">

<br />

위의 그림처럼 DOM, CSSOM 에 있던 속성들이 합쳐져 렌더트리를 구성하는 것을 확인할 수 있다. 그런데 화면에 보여주는데 쓰인다고 했지만, 렌더트리는 아직까지도 텍스트로 구성된 객체로밖에 보이지 않는다.

실제로 우리가 보는 페이지를 만들기 위해서는 페인팅이라는 작업을 거쳐야 한다. 페인팅 작업은 렌더트리의 노드들이 가지고 있는 속성들을 바탕으로 이루어지는데, 이 작업은 잠시 후에 다시 자세히 알아보도록 하고 우선은 Javascript 파일은 어떻게 해석이 되는지부터 잠시 살펴보자.

<br />
<br />

**3. Javascript 파싱**

<br />

브라우저 JS 엔진은 받아온 JS를 파싱해 AST를 생성하고, 바이트코드로 변환해 실행한다.

<br />

- 렌더링 엔진은 HTML 파일을 한줄씩 파싱하며 DOM을 생성하다가 Javascript 코드들 불러오는 script 태그를 만날 때도 파싱을 잠시 멈춘다.
- 그리고나서 src 속성에 적혀있는 파일을 서버에 요청해 받아온다. 이렇게 받아온 js파일도 마찬가지로 파싱을 해야하는데,
- 이 파싱은 브라우저 렌더링 엔진이 직접하지 않고, Javascript 엔진이 담당하게 된다.
- 이 때 렌더링 엔진은 JS엔진에게 제어권을 아예 넘겨주기 때문에, HTML 파싱을 멈췄다가 js파싱이 다되면 다시 제어권을 돌려받아 파싱을 다시 시작하는 것이다.

<br />

- JS엔진은 js파일의 코드를 파싱해서 컴퓨터가 이해할 수 있는 기계어로 변환하고 실행한다.
- 좀 더 구체적으로 살펴보면, 먼저 단순한 텍스트 문자열인 코드를 토큰 단위로 분해한다.
- 이렇게 분해된 토큰에 문법적인 의미와 구조가 더해져, AST(추상 구문 트리) 라는 트리가 완성된다.
- 구체적인 속성은 다르지만, 이전에 봤던 과정들과 비슷해 보인다. 아래 그림에서 맨 왼쪽의 코드가 바로 다음의 트리 구조로 바뀌는 부분이 여기까지의 내용에 해당한다.

<img width="392" alt="js" src="https://user-images.githubusercontent.com/109197023/222741372-8986e002-0e71-42b3-99fc-6119b6002d0c.PNG">

<br />

- LHS (left hand side) 변수는 다른 변수값을 지정하여 저장할 변수를, RHS (right hand side) 변수는 다른 변수에 저장될 변수값에 해당하는 변수를 뜻한다.
- 이제 이렇게 코드를 해석해서 만든 AST라는 트리를 실제로 실행할 수 있도록 만들어야 한다.
- 코드의 실제 실행은 인터프리터가 담당하는데, 인터프리터가 알아들을 수 있도록 하기 위해서는 AST트리를 바이트 코드라는 중간 수준의 코드로 변환해야 한다.
- 이 변환은 바이트코드 생성기가 담당해준다. 이제 위의 그림에서 가장 오른쪽에 있는 형태로 바뀌어 받아온 js파일 내용이 실제로 실행된다.

<br />
<br />

**4. 레이아웃(리플로우)**

<br />

렌더트리를 기반으로 HTML 요소의 레이아웃(위치, 크기)을 계산한다.

<br />

- 레이아웃은 요소의 기하학적인 속성들을 찾는 과정이다.
- 렌더트리에는 요소들의 위치나 크기와 관련된 정보들이 들어있었다. 하지만 이 정보들은 각 요소들에 대한 정보일 뿐, 전체 화면에서 정확히 어디에 위치할 것인지에 대해서는 아직 알지 못한다.
- 이런 계산을 하는 단계가 레이아웃 단계이다. 브라우저는 각 요소들이 전체 화면에서 어디에, 어떤 크기로 배치되어야 할 지 파악하기 위해 렌더트리의 맨 윗부분부터 아래로 내려가며 계산을 진행한다.
- 모든 값들은 절대적인 단위인 px값으로 변환된다.
- ex) 우리가 div요소 하나만 띄우도록 코드를 작성했고, width를 50%로 지정해두었다면, 이 값은 전체 화면 크기(viewport)의 절반 크기로 계산되고, 절대적인 값인 px 단위로 변환되는 식이다.

<br />

**5. 페인팅**

<br />

화면에 HTML요소를 페인팅한다.

- 이제 위치에 대한 계산도 마쳤으니, 정말로 화면에 보여줄 차례이다.
- 브라우저 화면은 픽셀이라고 하는 정말 작은 점들로 이루어져 있다.
- 각각 정보를 가진 픽셀들이 모여 하나의 이미지, 화면을 구성하는 것이다. 따라서 화면에 색상을 입히고, 어떤 요소를 보여주기 위해서는 이 픽셀에 대한 정보가 있어야 한다.
- 페인팅은 이러한 픽셀들을 채워나가는 과정이다.
- 따라서 이 과정을 마지막으로 우리는 단순한 텍스트에 불과했던 파일 내용들을 이미지화된 모습으로 브라우저 화면을 통해 볼 수 있게되는 것이다.

<br />
<br />

## 리플로우, 리페인트? & JS 실행

<br />

리플로우 -> 레이아웃 계산을 다시하는 것
리페인트 -> 새로운 렌더트리를 바탕으로 다시 페인트를 하는 것

- 만약 사용자가 브라우저 화면을 늘리거나 줄이는 등 크기를 조절하거나, 어떤 버튼을 눌러 화면에 요소가 추가되거나 삭제되는 경우가 생기면, 당연히 화면에 있던 요소들의 위치나 크기 등이 바뀌는 일이 생기게 될 것이다.
- 굉장히 당연하게 여겨지지만, 이렇게 화면에 나타나는 모습을 바꾸기 위해서는 모든 요소들의 위치와 크기를 다시 계산하고, 다시 그려서 보여주어야 한다.
- 이렇게 어떤 인터랙션으로 인해 앞서 보았던 레이아웃, 페인팅 과정을 반복하는 것을 **리플로우, 리페인트**라고 한다.
- DOM 조작은 리플로우, 리페인팅이 일어나는 대표적인 예시라고 할 수 있다.

<br />
<br />

JS 실행

```html
<head>
  <script src="main.js" />
</head>
```

<br />

☝️ 위처럼 추가할 경우 자바스크립트 파일이 크거나 인터넷이 느린 곳이라면 페에지를 보는데 오래 걸린다.

<br />

```html
<body>
</body>
<script>
<script>
```

☝️ 위처럼 추가할 경우 페이지를 먼저 볼 수는 있겠지만, 페이지가 js파일에 의존적이라고 하면 완전하지 않은
페이지를 볼 수 있다.

<br />

**async , defer 과 같은 속성도 참고하자**

<br />

이러한 브라우저의 랜더링 과정은 매우 복잡하며, 성능에 영향을 미치는 다양한 요인들이 존재한다. 따라서 개발자는 이 과정을 이해하고 최적화하는 데 노력해야 한다.

<br />
<br />

## 출처

> https://www.youtube.com/watch?v=hITJM_t1WWY&list=PLnSBcJpe92F8oBo6XgBt_0ErGPgdvgyg6&index=7&t=26s

> https://velog.io/@zaman17/%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91%EB%8C%80%EB%B9%84-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EB%A0%8C%EB%8D%94%EB%A7%81-%EC%88%9C%EC%84%9C%EC%99%80-%EC%9B%90%EB%A6%AC

> https://basemenks.tistory.com/292
